package main

import (
	"fmt"
)

func main() {
	// 练习1 从键盘接收一个整数作为层数，打印对应的金字塔
	// 金字塔最顶层是 1 个 *
	// 每多一层金字塔，下一层比上一层多 2 个 *

	// 思路分析
	// 先打印单边金字塔，即都从最左侧开始打印，每层多打 1 个 * 就换行
	// 定义变量 layer 接收自定义的层数

	/* 第一步，打印单边金字塔
	i 代表层数，j代表每层打印的 * 的个数，所以是个嵌套循环
	*
	**
	***
	即代表循环打印三层，每层打印的 * 个数，和层数相同
	*/

	/* 第二步，打印金字塔
	在每层的左侧都要打印空格，空格的数量等于 总层数 - 当前层数
	定义空格数量为 k
	  *      * 的数量 = 2 * 当前层数 - 1
	 ***
	*****
	*/

	/* 第三步，追加需求，要求打印空心金字塔
	不再是每层全部打印 * 需要判断何时打印 * ，否则打印 空格
	  *
	 * *
	*****
	条件有3:
	首层每层第一个，和最后一个打印 *
	第一层打印一个 *
	最后一层都打印 *
	*/

	var layer int
	fmt.Println("请输入大于1的整数")
	fmt.Scanln(&layer)
	for i := 1; i <= layer; i++ {
		for k := 0; k <= layer-i; k++ {
			fmt.Printf(" ")
		}
		for j := 1; j <= 2*i-1; j++ {
			if j == 1 || j == 2*i-1 || i == layer {
				fmt.Printf("*")
			} else {
				fmt.Printf(" ")
			}
		}
		fmt.Println()
	}

	// 练习2 打印九九乘法表
	/*
		1*1=1                    第一行第一列乘积
		1*2=2 2*2=4              第二行第一列 第二行第二列乘积
		1*3=3 2*3=6 3*3=9        第三行第一列 第三行第二列 第三行第三列乘积
		...

		思路分析：
		i j 分别代表行数，列数，循环上限都是 9


	*/
	var num int = 11
	for i := 1; i <= num; i++ {
		for j := 1; j <= i; j++ {
			fmt.Printf("%d * %d = %d\t", j, i, i*j)
		}
		fmt.Println()
	}
}
