package main

import "fmt"

// 递归调用

// 递归调用，就是在函数中再次调用函数本身
// 有以下要点：
// 1. 执行一个函数时，就创建一个新的受保护的独立空间（新函数栈）
// 2. 函数的局部变量是相互独立，互不影响的
// 3. 递归必须向退出递归调用的方向逼近，否则就会无限调用下去，直到崩溃

// 适用的场景：
// 有明确的递归边界条件
// 可以用有递归关系的自变量表示的函数表达式
// 如，求第 n 个斐波那契数 f(n)
// 边界条件： f(1) = f(2) =1
// 递归表达式： f(n) = f(n-1) + f(n-2)
// 递归表达式自变量减少时，边界条件在下，反之亦然，这里体现递归向可退出的方向逼近

func test(n int) {
	if n > 2 {
		n--     // 递归调用必须向退出递归调用的方向逼近
		test(n) // 递归调用
	}
	fmt.Println("n=", n)
}

func main() {
	test(4) //
}

// 以下是对这次递归调用的分析
/*

1. 主函数开始执行在栈区中生成了 main 栈区
2. main 调用了 test(4)  则在 main 栈区之上压栈 test1 栈区。

==========================
	test1 栈区：
	n=[4]
	判断 n > 2 成立
	n-- ==> n=[3]
	调用 test(3)
==========================

3. 调用 test(3) 则在 test1 栈区之上压栈 test2 栈区

==========================
	test2 栈区：
	n=[3]
	判断 n > 2 成立
	n-- ==> n=[2]
	调用 test(2)
==========================

4. 调用 test(2) 则在 test2 栈区之上压栈 test3 栈区

==========================
	test3 栈区：
	n=[2]
	判断 n > 2 不成立，跳过
	执行fmt，输出 n=2
	调用执行完毕，test3 栈区销毁，返回上一栈区
==========================

5. 返回 test2 栈区

==========================
	test2 栈区：
	n=[2]
	执行fmt，输出 n=2
	调用执行完毕，test2 栈区销毁，返回上一栈区
==========================

6. 返回 test1 栈区

==========================
	test1 栈区：
	n=[3]
	执行fmt，输出 n=3
	调用执行完毕，test1 栈区销毁，返回上一栈区
==========================

7. 返回 main 栈区，调用执行完毕，程序退出

8. 最终终端输出：

==========================
n=2
n=2
n=3
==========================

*/
