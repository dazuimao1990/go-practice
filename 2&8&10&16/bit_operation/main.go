package main

import "fmt"

func main() {

	// 位运算基础知识：
	// 原码 反码 补码，对于有符号的整数而言：
	// 1. 二进制的最高位代表符号，0代表正数，1代表负数
	// 2. 正数的 原码 反码 补码 都一样
	// 3. 负数的反码等于：符号位不变，其他位取反（0 -> 1, 1 -> 0）
	// 4. 负数的补码 = 反码 + 1
	// 5. 0 的反码 补码 都是0
	// 6. 计算机运算的时候，都以补码的方式运算
	// 7. 已知负数补码，求原码:符号位不变，取反加一
	//
	//  1: 原码 【0000 0001】 反码 【0000 0001】 补码 【0000 0001】
	// -1: 原码 【1000 0001】 反码 【1111 1110】 补码 【1111 1111】

	// 各种位运算：
	// 按位与 2&3 位对应判断，同为1时结果为1，否则为0
	// 2 补码 0000 0010
	// 3 补码 0000 0011
	// 2&3   0000 0010 ==> 2
	fmt.Println("2&3=", 2&3)

	// 按位或 2|3 位对应判断，两个中有一个为1时结果为1，否则为0
	// 2 补码 0000 0010
	// 3 补码 0000 0011
	// 2|3   0000 0011 ==> 3
	fmt.Println("2|3=", 2|3)

	// 按位异或 2^3 位对应判断，两个中有一个为1,另一个为0时，结果为1，否则为0
	// 2 补码 0000 0010
	// 3 补码 0000 0011
	// 2^3   0000 0001 ==> 1
	fmt.Println("2^3=", 2^3)

	// 有负数参与运算时，要转化为补码进行运算，所得的结果，也是补码，要转换成原码后转换十进制返回
	// 例如: -3^4
	// -3 原码 1000 0011
	// -3 反码 1111 1100
	// -3 补码 1111 1101
	//  4 补码 0000 0100
	// -3^4   1111 1001 =转反码:符号位不变，取反加一=> 10000111 ==> -7
	fmt.Println("-3^4=", -3^4)

	// 位移运算：
	// >> 右移时，符号位不变，左侧补零，右侧溢出时补零
	// << 左移时，符号位不变，右侧补零，左侧无溢出
	// 70 >> 2
	// 70 二进制 01000110
	// >>2      00010001 ==> 17
	//
	// 87 << 3
	// 87 二进制         01010111
	// <<3      0000001010111000 ==> 696
	//
	// -5 << 2
	// -5 二进制原码 10000101 反码 11111010
	// -5 补码 11111011
	// <<2    1111101100 =取反加一=> 1000010100 ==> -20
	fmt.Println(70 >> 2)
	fmt.Println(87 << 3) // = 696
	fmt.Println(-5 << 2)

	// 当限制了变量的取值类型时可能会导致左移溢出，进行了截断操作
	// 定义变量取值类型为 int8 即结果按照 8 位二进制截断
	// 87 << 3
	// 87 补码   01010111
	// << 3     10111000
	// 符号位为1，说明结果是负数，转换原码，取反加一 10111000 ==> 11001000 ==> -72
	var a int8 = 87
	fmt.Println(a << 3) // =-72

}
